---
Author:
  - Xinyang YU
Author Profile:
  - https://linkedin.com/in/xinyang-yu
tags:
  - OS
Creation Date: 2023-11-29T19:10:00
Last Date: 2024-04-20T22:25:15+08:00
References: 
sr-due: 2024-03-01
sr-interval: 8
sr-ease: 267
aliases:
  - ../../OS/Interrupts-(中断)/Interrupts-(中断)
---
## Interrupt
---
- When an interrupt occurs, [[Register#Program Counter]] jumps to [[Interrupt Handler]] & execute 


**Mechanism**
1. Causes [[Process (进程)]] to temporarily suspend
2. Save the state info of the process into the corresponding [[Process Control Block (PCB)]]
3. Executes the [[Interrupt Handler]]
4. When Interrupt Handler is done, the running [[Process (进程)]] is restarted and the state is restored from the PCB

>[!success] Free the CPU, no more Polling
> We don't need to get [[CPU]] to keep **Polling** for response which may take a long time to produce. Instead, send a notification to the CPU via interrupt. Thus, CPU is able to do other stuff while waiting for a response 


>[!caution] Generally can't be interrupted
> Interrupts are allowed to run to completion without being interrupted by other sources. For example, if a keyboard's interrupt is interrupted, we may lose the input from the keyboard
> 
> However, there are exceptions (This part I haven't explored yet)

>[!caution] Busy State
> As long as the [[Interrupt Handler]] is running, other interrupts may not be handled, and interrupts are generally not queued
> 
> But [[Interrupt Priorities]] exist in some systems to handle **Simultaneous Interrupts**

>[!tip]
>Interrupts should complete quickly to prevent the above problems





## Software Interrupt
---
- Follow the [[Sequential Circuit#Synchronous Sequential Circuit]] behaviour
- Request a **service** or **privileged operations** ([[System Call (系统调用)]]) from the [[Kernel]]

>[!success] Syscall brings Better Security
> Programs in [[User Space]] switching [[Privilege Level]] themselves is dangerous. With Software Interrupt, the [[CPU]] is preconfigured by Kernel with where in the kernel code to jump to

>[!example] Trap Interrupt
> Used to switch from [[Privilege Level#User Mode]] to [[Privilege Level#Kernel Mode]]. See [[Trap Interrupt (陷入)]] for more details.


## Upcall
---
![[software_interrupt.png|300]]

- Known as **Signal** in [[Unix#Unix-like]], or **Asynchronous Events** in **Windows**
- Follow the [[Sequential Circuit#Asynchronous Sequential Circuit]] behaviour, can occur at any time. Primarily focused on [[Inter-Process Communication (IPC)]] and **event handling** within a process
- Upcall allows us to insert [[#Upcall Handler]] to [[Process (进程)]], a way to bridge the gap between process and [[#Hardware interrupts (外中断)]]


>[!question] How is the upcall passed to the process?
> This upcall instructions are 'inserted' by the [[Interrupt Handler]] when the interrupt handler saves the process's [[Register#Program Counter]] during an [[Interrupts (中断)]] like [[Context Switch]]. Instead of saving the [[Memory Address]] of the current process instruction, the interrupt handler saves the memory address of the upcall instructions, so when the process is switched back, the process executes the upcall that is passed to it.


>[!example]
> **Generated by the kernel itself** 
> - [[Async IO]] notification
> - Logout — to notify applications that they should save file data and cleanly terminate
> - Resource adjustment - Java process can adapt to different amounts of available memory by changing the frequency of how often it runs its [[Garbage Collector]]. The more memory, the less time
> 
> **Generated by another process**
> - Termination signal – `SIGKILL`

>[!success] Asynchronous I/O notification
> A separate notification sent via an upcall to the application when the I/O completes. This eliminates waiting (idle) process that waits for IO [[System Call (系统调用)]] to complete!

### Upcall Handler
- A fixed set of [[Instruction]] the [[Kernel]] wants the [[Process (进程)]] to handle
- The process can register its own signal handler with the kernel to overwrite the default upcall handler the kernel provides

## Hardware interrupts (外中断)
---
- Raised by hardware devices. Follow the [[Sequential Circuit#Asynchronous Sequential Circuit]] behaviour, can occur at any time
- One example is [[Timer Chip]] used for [[Concurrency (并发)#Preemptive Scheduling]]
- We have a [[Interrupt Controller]] like the [[RISCV CLINT]] in RISCV to handle interrupt sources that share the same **interrupt pin**

>[!example]- Alarm Signal
> Sent after a specified number of seconds has elapsed to notify a process of an **event**

>[!example]- Turn off interrupt in XV6-RISCV
> This is achieved by writing to the [[Register#Control & Status Registers (CSRs)]] - `sstatus`. The code snippets below going down the [[Software Engineering/Abstraction]] 
> 
> `intr_off()` is the entry point
> ```c {8} title="spinlock.c"
> // XV6-RISCV kernel codes, spinlock.c
> 
> // ...
> void
> push_off(void)
> {
>   // ..
>   intr_off();
>   // ...
> }
> // ...
> ```
> 
> We can see from code snippet below, to disable the **interrupt** is setting the second bit from right on the `sstatus` register
> ```c {11} title="riscv.h"
> // XV6-RISCV kernel codes, riscv.h
> 
> // ...
> #define SSTATUS_SIE (1L << 1) // Supervisor Interrupt Enable
> 
> // ...
> // disable device interrupts
> static inline void
> intr_off()
> {
>   w_sstatus(r_sstatus() & ~SSTATUS_SIE);
> }
> // ...
> ```
> 
> Eventually, it boils down to [[Assembly language]]
> ```c {7} title="riscv.h"
> // XV6-RISCV kernel codes, riscv.h
> 
> // ...
> static inline void 
> w_sstatus(uint64 x)
> {
>   asm volatile("csrw sstatus, %0" : : "r" (x));
> }
> // ..
> ```